---
import Layout from "../layouts/Layout.astro";
import "./crosswords.css";
---

<Layout title="Lista E 2023">
  <main>
    <h1>Crosswords lista E 2023</h1>
    <div id="grid" class="grid"></div>
  </main>
</Layout>

<script>
  /* words */
  let words = [
    "redemption",
    "school",
    "forrest",
    "remember",
    "private",
    "knight",
    "father",
    "fiction",
    "fight",
    "beautiful",
    "history",
    "story",
    "future",
    "lost",
    "window",
    "unchained",
    "west",
    "shining",
    "glory",
    "hunting",
    "dogs",
    "dollar",
    "mockingbird",
    "citizen",
    "music",
    "inside",
    "wolf",
    "index",
    "begin",
    "mind",
    "crusade",
    "shack",
    "escape",
    "quiet",
    "happy",
    "boy",
    "bridge",
    "wind",
    "ridge",
    "girl",
    "galaxy",
    "island",
    "dragon",
    "hotel",
    "sense",
    "show",
    "park",
    "society",
    "deliver",
    "pale",
    "day",
    "room",
    "mean",
    "saints",
    "black",
    "survivor",
    "letter",
    "flag",
    "apocalypse",
    "jacket",
    "notebook",
    "prejudice",
    "harbor",
    "dirty",
    "soldiers",
    "walk",
    "silver",
    "holiday",
    "hitch",
    "woman",
    "clueless",
    "sleep",
    "wedding",
    "sweet",
    "figures",
    "network",
    "green",
    "big",
    "captain",
    "catch",
    "polar",
    "christmas",
    "yesterday",
    "cable",
    "righteous",
    "learn",
    "mask",
    "panther",
    "marvel",
    "venom",
    "avenger",
    "iron",
    "thorn",
    "incredible",
    "hood",
    "doubt",
    "wizard",
    "rhapsody",
    "hateful",
    "squad",
    "zombie",
    "quickly",
    "english",
    "country",
    "reign",
    "gladiator",
    "chariots",
    "millionaire",
    "book",
    "psycho",
    "vertigo",
    "taken",
    "pursuit",
    "gangs",
    "movie",
    "silence",
    "fire",
    "passion",
    "giants",
    "prince",
    "seven",
    "sixth",
    "prestige",
    "instinct",
    "unbreakable",
    "glass",
    "split",
    "scream",
    "fugitive",
    "conjuring",
    "sinister",
    "insidious",
    "project",
    "abstraction",
    "grudge",
    "blazing",
    "super",
    "fuzz",
    "thunder",
    "school",
    "office",
    "stripes",
    "animal",
    "raising",
    "paid",
    "ball",
    "basketball",
    "pardon",
    "elimination",
    "conservative",
    "economics",
    "global",
    "rotund",
    "examination",
    "plump",
    "healing",
    "graceful",
    "merciful",
    "lovely",
    "industrial",
    "apartment",
    "astronomy",
    "groceries",
    "abomination",
    "temptation",
    "growth",
    "brothers",
    "communication",
    "positivity",
    "hopeful",
    "oranges",
    "thinking",
    "wanderer",
    "independent",
    "liberty",
    "savior",
    "enlightenment",
    "restoration",
    "church",
    "follower",
    "judicial",
    "discipline",
    "prayer",
    "ammunition",
    "assault",
    "machine",
    "computer",
    "programming",
    "science",
    "artificial",
    "courage",
    "cowardly",
    "hound",
    "assassin",
    "discussion",
    "guitar",
    "piano",
    "believer",
    "exponential",
    "happiness",
    "justice",
    "levity",
    "fantasy",
    "fiction",
    "worship",
    "stranger",
    "mysterious",
    "fallout",
    "nuclear",
    "reaction",
    "revolution",
    "chicken",
    "pasture",
    "blink",
    "knowledge",
    "jumping",
    "jaded",
    "jewel",
    "kingdom",
    "kindred",
    "kindness",
    "league",
    "nugget",
    "never",
    "need",
    "negligent",
    "opening",
    "oligarchy",
    "oval",
    "queen",
    "quiver",
    "training",
    "three",
    "tale",
    "tavern",
    "requiem",
    "ugly",
    "under",
    "upper",
    "vitamin",
    "very",
    "variety",
    "values",
    "victory",
    "warrior",
    "yellow",
    "yearning",
    "yourself",
    "yogurt",
    "zebra",
    "zeppelin",
  ];

  function Word(text, row, column, vertical) {
    this.text = text;
    this.row = row;
    this.column = column;
    this.vertical = vertical;
  }

  function CrosswordPuzzle() {
    const emptyCell = "_";
    let grid = Array.from(Array(gridSize), () => new Array(gridSize));
    for (let row = 0; row < gridSize; row++) {
      for (let column = 0; column < gridSize; column++) {
        grid[row][column] = emptyCell;
      }
    }

    let update = function (word) {
      let updated = false;
      if (canBePlaced(word)) {
        addWord(word);
        updated = true;
      }

      return updated;
    };

    let canBePlaced = function (word) {
      let canBePlaced = true;
      if (isValidPosition(word.row, word.column) && fitsOnGrid(word)) {
        let index = 0;
        while (index < word.text.length) {
          let currentRow = word.vertical ? word.row + index : word.row;
          let currentColumn = !word.vertical
            ? word.column + index
            : word.column;

          if (
            (word.text.charAt(index) === grid[currentRow][currentColumn] ||
              emptyCell === grid[currentRow][currentColumn]) &&
            placementLegal(word, currentRow, currentColumn)
          ) {
            //We can place a word!
          } else {
            canBePlaced = false;
          }
          index++;
        }
      } else {
        canBePlaced = false;
      }

      return canBePlaced;
    };

    let getIntersections = function () {
      let intersections = 0;
      for (let row = 0; row < gridSize; row++) {
        for (let column = 0; column < gridSize; column++) {
          if (isLetter(row, column)) {
            if (
              isValidPosition(row - 1, column) &&
              isValidPosition(row + 1, column) &&
              isValidPosition(row, column - 1) &&
              isValidPosition(row, column + 1) &&
              isLetter(row - 1, column) &&
              isLetter(row + 1, column) &&
              isLetter(row, column - 1) &&
              isLetter(row, column + 1)
            ) {
              ++intersections;
            }
          }
        }
      }
      return intersections;
    };

    let placementLegal = function (word, row, column) {
      let illegal = false;
      if (word.vertical) {
        illegal =
          isInterference(row, column + 1, row + 1, column) ||
          isInterference(row, column - 1, row + 1, column) ||
          overwritingVerticalWord(row, column) ||
          invadingTerritory(word, row, column);
      } else {
        illegal =
          isInterference(row + 1, column, row, column + 1) ||
          isInterference(row - 1, column, row, column + 1) ||
          overwritingHorizontalWord(row, column) ||
          invadingTerritory(word, row, column);
      }
      return !illegal;
    };

    let invadingTerritory = function (word, row, column) {
      let invading = false;
      let empty = isEmptyCell(row, column);
      if (word.vertical) {
        let weHaveNeighbors =
          doesCharacterExist(row, column - 1) ||
          doesCharacterExist(row, column + 1) ||
          (endOfWord(word, row, column) && doesCharacterExist(row + 1, column));

        invading = empty && weHaveNeighbors;
      } else {
        let weHaveNeighbors =
          doesCharacterExist(row - 1, column) ||
          doesCharacterExist(row + 1, column) ||
          (endOfWord(word, row, column) && doesCharacterExist(row, column + 1));

        invading = empty && weHaveNeighbors;
      }
      return invading;
    };

    let endOfWord = function (word, row, column) {
      if (word.vertical) {
        return word.row + word.text.length - 1 === row;
      } else {
        return word.column + word.text.length - 1 === column;
      }
    };

    let doesCharacterExist = function (row, column) {
      return isValidPosition(row, column) && isLetter(row, column);
    };

    let overwritingHorizontalWord = function (row, column) {
      let leftColumn = column - 1;
      return (
        isValidPosition(row, leftColumn) &&
        isLetter(row, column) &&
        isLetter(row, leftColumn)
      );
    };

    let overwritingVerticalWord = function (row, column) {
      let rowAbove = row - 1;
      return (
        isValidPosition(rowAbove, column) &&
        isLetter(row, column) &&
        isLetter(rowAbove, column)
      );
    };

    let isInterference = function (row, column, nextRow, nextColumn) {
      return (
        isValidPosition(row, column) &&
        isValidPosition(nextRow, nextColumn) &&
        isLetter(row, column) &&
        isLetter(nextRow, nextColumn)
      );
    };

    let isLetter = function (row, column) {
      return grid[row][column] !== emptyCell;
    };

    let isEmptyCell = function (row, column) {
      return !isLetter(row, column);
    };

    let addWord = function (word) {
      for (let letterIndex = 0; letterIndex < word.text.length; ++letterIndex) {
        let row = word.row;
        let column = word.column;
        if (word.vertical) {
          row += letterIndex;
        } else {
          column += letterIndex;
        }

        grid[row][column] = word.text.substring(letterIndex, letterIndex + 1);
      }
    };

    let fitsOnGrid = function (word) {
      if (word.vertical) {
        return word.row + word.text.length <= gridSize;
      } else {
        return word.column + word.text.length <= gridSize;
      }
    };

    let isValidPosition = function (row, column) {
      return row >= 0 && row < gridSize && column >= 0 && column < gridSize;
    };

    return {
      grid: grid,
      update: update,
      isLetter: isLetter,
      getIntersections: getIntersections,
    };
  }

  const attemptsToFitWords = 5000;
  const gridsToMake = 20;
  const gridSize = 20;

  let usedWords = [];
  let generatedGrids = [];
  let goodStartingLetters = new Set();

  let slots = gridSize * gridSize;
  let gridDiv = document.getElementById("grid");
  let row = 0;
  let column = 0;
  for (let slot = 0; slot < slots; slot++) {
    let div = document.createElement("DIV");
    div.id = row + "_" + column;
    div.classList.add("slot");
    div.style.border = "1px solid #e9e9e9";
    div.style.backgroundColor = "#e9e9e9";
    gridDiv.appendChild(div);
    column++;
    if (column >= gridSize) {
      column = 0;
      row++;
    }
  }

  let createCrossWordPuzzle = function () {
    let attemptToPlaceWordOnGrid = function (grid, word) {
      let text = getAWordToTry();
      for (let row = 0; row < gridSize; ++row) {
        for (let column = 0; column < gridSize; ++column) {
          word.text = text;
          word.row = row;
          word.column = column;
          word.vertical = Math.random() >= 0.5;

          if (grid.isLetter(row, column)) {
            if (grid.update(word)) {
              pushUsedWords(word.text);
              return true;
            }
          }
        }
      }
      return false;
    };

    let getAWordToTry = function () {
      let word = getRandomWord(words);
      let goodWord = isGoodWord(word);

      while (usedWords.includes(word) || !goodWord) {
        word = getRandomWord(words);
        goodWord = isGoodWord(word);
      }
      return word;
    };

    let getBestGrid = function (grids) {
      let bestGrid = grids[0];
      for (let grid of grids) {
        if (grid.getIntersections() >= bestGrid.getIntersections()) {
          bestGrid = grid;
        }
      }
      return bestGrid;
    };

    let isGoodWord = function (word) {
      let goodWord = false;
      for (let letter of goodStartingLetters) {
        if (letter === word.charAt(0)) {
          goodWord = true;
          break;
        }
      }
      return goodWord;
    };

    let generateGrids = function () {
      generatedGrids = [];

      for (let gridsMade = 0; gridsMade < gridsToMake; gridsMade++) {
        let grid = CrosswordPuzzle();
        let word = new Word(
          getRandomWordOfSize(getUnusedWords(), 9),
          0,
          0,
          false
        );
        grid.update(word);
        pushUsedWords(word.text);

        let continuousFails = 0;
        for (let attempts = 0; attempts < attemptsToFitWords; ++attempts) {
          let placed = attemptToPlaceWordOnGrid(grid, word);
          if (placed) {
            continuousFails = 0;
          } else {
            continuousFails++;
          }
          if (continuousFails > 470) {
            break;
          }
        }

        generatedGrids.push(grid);
        if (grid.getIntersections() >= 4) {
          break;
        }
        usedWords = [];
      }
    };

    let displayCrosswordPuzzle = function (bestGrid) {
      for (let row = 0; row < gridSize; ++row) {
        for (let column = 0; column < gridSize; ++column) {
          let slot = document.getElementById(row + "_" + column);
          if (bestGrid.isLetter(row, column)) {
            slot.innerHTML = bestGrid.grid[row][column];
            slot.style.borderBottom = "1px solid #9a8e9a";
            slot.style.borderRight = "1px solid #9a8e9a";
            slot.style.backgroundColor = "rgb(102, 178, 255)";
          } else {
            slot.innerHTML = "";
            slot.style.border = "1px solid #e9e9e9";
            slot.style.backgroundColor = "#e9e9e9";
          }
        }
      }
    };

    let pushUsedWords = function (text) {
      usedWords.push(text);
      text.split("").filter((char) => goodStartingLetters.add(char));
    };

    generateGrids();
    let bestGrid = getBestGrid(generatedGrids);
    displayCrosswordPuzzle(bestGrid);
  };

  function getUnusedWords() {
    return words.filter((val) => !usedWords.includes(val));
  }

  function getRandomWordOfSize(wordList, wordSize) {
    let properLengthWords = wordList.filter((val) => val.length >= wordSize);
    return properLengthWords[getRandomInt(properLengthWords.length)];
  }

  function getRandomWord(wordList) {
    let words = getUnusedWords();
    return words[getRandomInt(words.length)];
  }

  function getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
  }

  createCrossWordPuzzle();
</script>

<style>
  main {
    margin: auto;
    padding: 1.5rem;
    max-width: 60ch;
  }
  h1 {
    font-size: 3rem;
    font-weight: 800;
    margin: 0;
  }
</style>
